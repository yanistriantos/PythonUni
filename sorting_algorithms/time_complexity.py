time_complexities_explained = """
### O(1) - Константна сложност
- **Обяснение**:  
  Алгоритъмът винаги отнема **едно и също време**, независимо от размера на входните данни.  
- **Пример**:  
  Достъп до елемент в масив по индекс.

---

### O(n) - Линейна сложност
- Обяснение:  
  Времето за изпълнение нараства **линейно** с увеличаване на броя елементи (n). Ако n се удвои, времето също се удвоява.  
- **Пример**:  
  Търсене на елемент в несортиран списък.

---

### O(n²) - Квадратична сложност
- **Обяснение**:  
  Времето за изпълнение нараства **квадратично** с увеличаване на броя елементи (n). Ако n се удвои, времето се увеличава 4 пъти.  
- **Пример**:  
  Bubble Sort, Selection Sort, Insertion Sort.

---

### O(log n) - Логаритмична сложност
- **Обяснение**:  
  Времето за изпълнение нараства **бавно** с увеличаване на броя елементи (n). Ако n се удвои, времето се увеличава само с константа.  
- **Пример**:  
  Двоично търсене (Binary Search) в сортиран списък.

---

### O(n log n) - Линеарно-логаритмична сложност
- **Обяснение**:  
  Времето за изпълнение нараства **умерено** с увеличаване на броя елементи (n). Това е по-бързо от O(n²), но по-бавно от O(n).  
- **Пример*:  
  Merge Sort, Quick Sort (среден случай), Heap Sort.

---

### O(n!) - Факториелна сложност
- **Обяснение**:  
  Времето за изпълнение нарастава **експоненциално** с увеличаване на броя елементи (n). Това е най-неефективната сложност.  
- **Пример**:  
  Bogo Sort, решаване на задачата за "пътуващия търговец" (Brute Force).
"""
